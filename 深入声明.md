# 目录

- [声明原理](#声明原理)
- [内部声明](#内部声明)
- [外部声明](#外部声明)
- [.d.ts和三斜线指令](#.d.ts和三斜线指令)

<h1 id="声明原理">声明原理</h1>

> 声明的本质是告知编译器一个标识符的**类型信息**

声明在TypeScript中至关重要，只有通过声明才能告知编译器一个随机出现的标识符到底代表什么含义。对于语言关键字之外的**任意标识符**，如果编译器无法获取它的声明，将会报错：

```typescript
// 错误，凭空出现的variable， 编译器无法知道它代表什么含义
// error TS2304: Cannot find name 'variable'
console.log(variable);
```

改正这个错误，需要添加 `variable` 的声明信息：


```typescript
// 声明语句
let variable: number;
// 正确，已声明variable为数字
console.log(variable);
```

> 虽然编译成JavaScript代码执行时仍然会报错，但因为添加了`variable`的声明信息，在TypeScript中逻辑合理，不会报错


<h1 id="内部声明">内部声明</h1>

到目前为止，所有在TypeScript源码中出现的声明，都是内部声明：

```typescript
// 声明a为一个数字
let a: number;
// 声明b为一个数字并初始化为2
let b: number = 2;

// 声明T为一个接口
interface T {}
// 声明接口类型变量b
let b: T;

// 声明fn为一个函数
function fn(){}

// 声明myFunc为一个函数
// 此处利用了类型推导
let myFunc = function(a: number){}

// 声明MyEnum枚举类型
enum MyEnum {
  A, B
}

// 声明NS为命名空间
namespace NS {}

// ...
```


<h1 id="外部声明">外部声明</h1>

外部声明主要针对于JavaScript，当需要在TypeScript代码中用到JavaScript编写的库时就会遇到问题。假设我们在HTML中通过`script`标签引入了`jQuery`:

```html
// 注册全局变量 $
<script src="path/to/jquery.js"></script>
```

`path/to/jquery.js` 文件在全局作用域中引入了全局变量 `$`，接下来如果在另一个TypeScript文件中使用 `$`，程序会报错：

```typescript
// 错误，缺少名字 $ 的声明信息
// error TS2581: Cannot find name '$'. Do you need to install type definitions for jQuery? Try `npm i @types/jquery`
$('body').html('hello world');
```

由于没有声明信息，编译器根本不知道 `$` 代表什么意思。此时需要引入**外部声明**（因为`$`是外部JavaScript引入的）。外部声明的关键字是：

```typescript
declare 
```


分析语句 `$('body').html('hello world');` 得出：

- $ 是一个函数，接收字符串参数 
- $ 返回值是一个对象类型，此返回类型拥有成员函数 `html`，这个成员函数的参数也是字符串类型

```typescript
// 声明 $ 的类型信息
declare let $: (selector: string) => {
  html: (content: string) => void;
};

// 正确，$已经通过外部声明
$('body').html('hello world');
```

声明应该是纯粹对于一个标识符**类型或外观的描述**，便于编译器识别，外部声明具有以下特点:

- 必须使用 `declare` 修饰外部声明
- 不能包含实现或初始化信息（内部声明可以在声明的时候包含实现或初始化）

```typescript
// 声明a为一个数字
declare let a: number;
// 错误，外部声明不能初始化
// error TS1039: Initializers are not allowed in ambient contexts
declare let b: number = 2;

// 声明T为一个接口
declare interface T {}
// 声明接口类型变量b
let b: T;

// 声明fn为一个函数
// 错误，声明包含了函数实现
// error TS1183: An implementation cannot be declared in ambient contexts
declare function fn(){}

// 正确，不包含函数体实现
declare function fn(): void;

// 声明myFunc为一个函数
declare let myFunc: (a: number) => void;

// 声明MyEnum枚举类型
declare enum MyEnum {
  A, B
}

// 声明NS为命名空间
declare namespace NS {
  // 错误，声明不能初始化
  // error TS1039: Initializers are not allowed in ambient contexts
  const a: number = 1;
  // 正确，仅包含声明
  const b: number;
  // 正确，函数未包含函数体实现
  function c(): void;
}

// 声明一个类
declare class Greeter {
    constructor(greeting: string);
    greeting: string;
    showGreeting(): void;
}
```

外部声明还可以用于声明一个**模块**，如果一个外部模块的成员要被外部访问，模块成员应该用 `export` 声明导出：

```typescript
declare module 'io' {
  export function read(file: string): string;
  export function write(file: string, data: string): void;
}
```


<h1 id=".d.ts和三斜线指令">.d.ts 和三斜线指令</h1>


> 本教程偏向语法，本节内容超出教程范畴，仅做简单讲解

习惯上，常常把外部声明写在一个后缀名为 `.d.ts` 的声明文件中，然后用三斜线指令引入进来

```typescript
// jquery.d.ts 文件
declare let $: (selector: string) => {
  html: (content: string) => void;
};

// main.ts 文件
/// <reference path="./jquery.d.ts" />
$('body').html('hello world');
```

上述语句声明了 `main.ts` 依赖 `jquery.d.ts` 声明文件，在编译阶段，被依赖文件 `jquery.d.ts` 将被包含进来，就像将被依赖文件的源码展开在依赖声明处一样：

```typescript
// main.ts文件等价于将代码展开
declare let $: (selector: string) => {
  html: (content: string) => void;
};
$('body').html('hello world');
```

三斜线指令中需要注意的是 `path` 类型和 `type` 类型的区别：

```typescript
/// <reference path="./jquery.d.ts" />
/// <reference types="node" />
```

- `path` 类型声明的是对本地文件的依赖，包含路径信息
- `types` 类型声明的是对 `node_modules/@types` 文件夹下的类型的依赖，不包含路径信息





