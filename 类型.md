# 目录

- [值](#值)
- [类型判定](#类型判定)

<h1 id="值">值</h1>

值就是数据，凡是**可以被变量存储的单元**都是值。它可以是简单的字符串、数字、符号等，也可以是复杂的由多条语句组成的代码单元，如类、函数、对象等：

```typescript
// 字符串作为值
let value = 'hello world';

// 对象字面量作为值
let value = {
  attribute: 'hello world'
};

// 函数作为值
let value = function(){
  // ...
}

function fn(){
  return 'hello world';
}
// 函数返回作为值
let value = fn();

// 类作为值
let value = class {
  // ...
}
```

<h1 id="类型判定">类型判定</h1>

**在TypeScript中，所有的值都具有强制类型**，这是Typescript区别于JavaScript的最显著的特点。编译器可以通过三种方式获取值的类型:

- 类型注解
- 类型推导
- 类型查询

<h2 id="类型注解">类型注解</h2>

类型注解是指在源代码中显式指定值的类型。

### 语法

```
: 类型
```

**冒号加类型**构成了类型注解，冒号前后可以包含任意空格。以下都是合法的类型注解语法

```typescript
// 声明字符串类型变量
let variable: string;

// 声明字符串类型变量并初始化
let variable: string = 'hello world';

// 指定类的属性类型
class Hello {
  attribute: boolean;
}

// 指定函数参数和返回值类型
function show(a: number, b: number): number {
  return a + b;
}
```

### 概览

下表列出了TypeScript支持的所有类型，作为汇总，后续章节会详细讨论

描述|类型 
-|-
数字类型 | `number`
布尔类型 | `boolean`
字符串类型 | `string`
符号类型 | `symbol`
Void类型 | `void`
Null类型 | `null`
Undefined类型 | `undefined`
Never类型 | `never`
任意类型 | `any`
数组类型 | `T[]`
元组类型 | `[T0, T1, ...]`
枚举类型 | `enum T { ... }`
函数类型 | `(p1: T1, p2: T2, ...) => T`
类类型 | `T`
构造器类型 | `new (p1: T1, p2: T2, ...) => R`
对象类型 | `{ ... }` 或 `interface T{ ... }`
联合类型 | `T1 | T2 | ...`
交叉类型 | `T1 & T2 & ...`

<h2 id="类型推导">类型推导</h2>

类型注解不是必须的，编译器足够**聪明**，在绝大多数未显式注解类型的情况下，能自动推导出值的类型。

> 基本上可以这么简单理解：如果你的肉眼能看出一个未注解的值的类型，那么编译器也能推导出来

```typescript
// 变量被自动推导为字符串类型 `string`
let variable = 'hello world';
// 相当于
let variable: string = 'hello world';

// 返回值被自动推导为数字类型 `number`
function show(param: number) {
  return param;
}
// 相当于
function show(param: number): number {
  return param;
}
```

<h2 id="类型查询">类型查询</h2>

类型查询是一条语句，**相当于一个独立类型**。任何需要显式注解类型的地方，都可以使用类型查询。

### 语法

```
typeof 值
```

在JavaScript中，`typeof` 是一个用来判断值类型的关键字，在类型查询语法中有类似的作用。

```typescript
let a: number;
let b: typeof a;
// 相当于
let b: number;

// 函数fn会被推导为 () => void 类型
function fn(){}
let d: typeof fn;
// 相当于
let d: () => void;
```
