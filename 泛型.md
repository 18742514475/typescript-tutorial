# 目录

- [泛型](#泛型)
- [泛型约束](#泛型约束)
- [泛型数组](#泛型数组)

<h1 id="泛型">泛型</h1>

泛型可以为**函数、接口、类**定义**类型变量**，这些类型变量就像真实存在的类型一样，可以用于注解值的类型

### 语法

```
名字<T1, T2, ...>
```

`名字`表示**函数名、接口名、类名**，`T1, T2, ...` 表示一个或多个**名字任意**的类型变量，实际开发中常常以**首字母大写**的标识符作为类型变量名。泛型在使用时**必须以真实类型替换类型变量**


### 泛型函数

```typescript
// 定义泛型函数，类型变量为T
// T接下来在"参数、返回值、变量"定义中可以作为类型使用
function identity<T>(m: T): T {
  // T 注解了函数内部的变量定义
  let n: T = m;
  return n;
}

// 调用泛型函数，此时用string类型替换类型变量 T
// identity<string> 作为一个整体相当于一个函数名
let m: string = identity<string>('hello world');
```

### 泛型类

```typescript
// 定义泛型类，包含两个类型变量
class Identity<T1, T2> {
  attr1: T1;
  attr2: T2;
  show(m: T1, n: T2): T2{
    return n;
  }
}

// 用真实类型替换泛型类的类型变量
// Identity<string, number>作为一个整体相当于一个类名
let a: Identity<string, number>;
// 初始化变量a
a = new Identity<string, number>();
// T1=>string，T1被替换为string，属性attr1为字符串类型
a.attr1 = 'hello';
// T2=>number，T2被替换为number，属性attr2位数字类型
a.attr2 = 99;

// 错误，类型不匹配
// error TS2322: Type '"good"' is not assignable to type 'number'
a.attr2 = 'good';
```

### 泛型接口
```typescript
// 定义泛型接口
interface Identity<T> {
  attr: T;
}

// 用真实类型替换泛型接口的类型变量
// Identity<number>作为一个整体相当于一个接口名
let a: Identity<number> = {attr: 10};
// Identity<string>作为一个整体相当于一个接口名
let b: Identity<string> = {attr: 'hello'};

// 错误，类型不匹配
// error TS2322: Type 'number' is not assignable to type 'boolean'.
let c: Identity<boolean> = {attr: 10};

// 一个复杂点的例子
function fn(){};
let c: Identity<typeof fn> = {
  attr(){}
}
```


<h1 id="泛型约束">泛型约束</h1>

必须谨慎使用类型变量，参考下面的例子：

```typescript
// 定义泛型函数
function getLength<T>(arg: T): number {
  // 错误，参数arg 没有属性 length
  // error TS2339: Property 'length' does not exist on type 'T'
  return arg.length;
}
```

没有任何地方表明类型 `T` 类型的参数 `arg` 包含属性 `length`，因而编译器报错。为了改正上述代码，需要要约束类型变量 `T` 必须包含属性 `length`

### 语法

```
类型变量 extends 类型
```

类型约束关键字为 `extends`，和继承关键字一样。实际上，类型约束跟继承同义，类型变量继承了被约束类型的所有成员

```typescript
// 声明接口
interface WithLength {
  length: number;
}

// 正确，T现在被接口类型WithLength约束，包含属性 length
function getLength<T extends WithLength>(arg: T): number {
  return arg.length;
}
```


<h1 id="泛型数组">泛型数组</h1>

### 语法

```
Array<T>
// 只读数组
ReadonlyArray<T>
```

Typescript 对数组类型进行了扩展，可以用泛型语法声明数组：

```typescript
// 定义数字数组
let arr: number[] = [1, 2, 3];

// 完全等价于
let arr: Array<number> = [1, 2, 3];
```

只读数组的值一旦初始化，就不能再改变：

```typescript
let arr: ReadonlyArray<number> = [1, 2, 3];

// 错误，只读数组的元素值不能改变
// error TS2542: Index signature in type 'ReadonlyArray<number>' only permits reading
arr[0] = 11;
```





